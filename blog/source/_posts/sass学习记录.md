---
title: sass学习记录
date: 2017-09-13 22:46:07
tags: [sass]
categories: sass
---

# sass 学习经验

## mixin的使用
sass 的mixin 宏使用方法:相当于函数，可以传入参数，但是mixin不可大量使用，会造成代码冗余。
### 未带参数类型
```
@mixin leftbar{
	position:absolute;
	left:0;
	top:0;
	bottom:0;
	width:100px;
}
div{
	@include leftbar
}
.otherbox{
	@include leftbar;
}

```
生成的css 文件就会把leftbar 的内容放进div的样式中。不会自动合并使用相同样式的代码块。
### 带参数类型
```
@mixin leftbar($width){
	position:absolute;
	left:0;
	top:0;
	bottom:0;
	width:$width
}
div{
	@include leftbar(200px);
}
```
mixin 的参数可以带多个，当参数过多可用...代替。由于大量的冗余代码，此功能最好适用于带有参数的重用代码块中，写死的代码块使用继承来做。

## 类继承的使用
@extend 如名所示，可以用来继承样式，mixin 的大量使用造成冗余，使用extend 可以做到降低冗余。@extend的用法就相当于设置一个类名.
```
.samestyle{
	width:100px;
	height:70px;
	color:red;
}
.otherbox{
	@extend .samestyle
}
.div{
	@extend .samestyle
}
```
编译出来的css 文件就会合并相同的样式，
```
.otherbox,div{
	width:100px;
	height:70px;
	color:red;
}
```
这点就解决了mixin的代码冗余问题。extend 的缺点也存在，由于它是类名，在使用中可能会造成混乱，最后sass也不知道哪个才是声明的类名。
## %palceholder占位符的使用
此功能暂时还没有怎么研究，简单来说跟mixin和继承的功能类似。


## sass定义变量

```
$color:red
div{
	color:$color
}
```
可以定义默认变量!default。如果要覆盖默认变量，在默认变量前重写变量
```
$line-height:1.5
$line-height:1.8 !default
div{
	line-height:$line-height
}
```
此时生成的css 文件的line-height 为1.5
## sass 文件import 
sass 可以导入局部文件不用生成css文件，在文件命名加入下划线，导入的时候省略下划线。

## sass嵌套功能
sass 的嵌套功能能让我们清楚的看到每个节点的相互关系，但是在方便和清晰的同时却不能忘记这个“好处”能让问题复杂化，在我初识sass的时候就是看上了这个嵌套功能以致于瞎用，滥用。完全没有考虑层级问题。一条路走到底。最后完全陷入混乱，继承关系太过复杂自己也理不清了。在某天系统的学习了一下sass后，也就是在学完后写了这篇学习笔记。
看了很多规范说嵌套最好的层级不要超过4层，本人的理解太深的层级会造成代码重叠和继承关系太过复杂，当在某个地方出错后很难定位哪里出问题。而且修改起来也较为麻烦，毕竟各个地方相互影响着。还有就是太深选择器的层次也就越深，在性能方面必然会影响一些，这个性能方面的问题没有深究。但是选择器如果多了对css的权重影响很大，在很多时候可能就是因为优先级权重问题修改样式失败。
## 对于sass的使用
在我看来sass的强大之处应该是在于其减少css的代码，在我平时的工作在此项的使用还是很少，用的比较多的就是px转换到rem 的函数使用。还有用的比较多的是嵌套。在实际写css的时候对代码量的考虑太少，可能还是因为经验不足的原因对于某些常见样式的提取的敏感度不够。在今后的工作中可以试着提取相同代码模块化的形式写入。
## 题外话
就css的问题在移动端上遇到了挺多了。就最近在写一个弹框的时候遇到了移动端穿透问题和定位问题。在我看来写弹框的定位最好还是使用fixed比较合适，看了别人的代码都是用的absolute写定位，在我使用绝对定位时候，由于页面的高度超过屏幕高度，所以在滑在下面的时候弹出弹框此时的定位就会错，如果是采用fixed就会相对屏幕定位每次弹出位置都在屏幕的中间。移动端穿透问题，简单说来就是弹出框后下面的图层还是可以点或者滑动。就解决方案有几种，我采用过两种，都有一点弊端。
1.弹出时将body设置成overflow:hidden。 这种方式确实也能解决到下面图层不能点击了，但是对于有bg的body 还是能够滑动，所以此种方案并不可行。
2.对弹出层监听touch事件并阻止其冒泡。
```
dialog.addEventListener('touchmove',(e)=>{
	e.preventDefault();
})
```
这种方案基本能解决我想要的需求不能点击且不能滑动。但是弊端就是如果弹出框的文本过多也不能滑动。在pc的chrome上模拟不能测试，请在真机上测试。

----
## 补充移动端穿透问题
这次在工作中又写到一个需求需要在弹框里面滑动，所以这里上面讲的两种方案都是不可行的。这里就查到了第三种方案，就是在弹出弹框后给body的定位改成fixed，这样body就不能滑动了，但是缺陷就是滑动条会缺失。再深的需求就是要关闭弹框后滑动条还是在那个位置，就需要监听弹框弹出来时候body的scrolltop，在关闭弹框的事件把这个scrolltop设置上，这样就完美的解决了移动端穿透问题。
