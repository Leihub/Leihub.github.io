<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>leihoyoa</title>
    <link>http://yomark.club/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>前端|hexo|技术|学习</description>
    <pubDate>Sun, 16 Jun 2019 14:51:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>记2019第一次面试</title>
      <link>http://yomark.club/%E8%AE%B02019%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</link>
      <guid>http://yomark.club/%E8%AE%B02019%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</guid>
      <pubDate>Fri, 14 Jun 2019 13:22:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;工作两年来第一次出去面试，早上八点就出门去公交站挤公交，大概有很长时间没有挤公交，也没有体验过工作日的早高峰挤公交真的挤上公交就觉得后悔。此次出去面试的目的也不是为了真的工作，也是因为两年了一直在舒适圈温水煮青蛙想出去锻炼下自己。见识一下社会的残酷。哈哈哈。大概九点就到了面
        
      
      </description>
      
      <content:encoded><![CDATA[<p>工作两年来第一次出去面试，早上八点就出门去公交站挤公交，大概有很长时间没有挤公交，也没有体验过工作日的早高峰挤公交真的挤上公交就觉得后悔。此次出去面试的目的也不是为了真的工作，也是因为两年了一直在舒适圈温水煮青蛙想出去锻炼下自己。见识一下社会的残酷。哈哈哈。大概九点就到了面试地点，在吧台看了一会笔记就上了，开干。<br>一开始面试官就跟我聊了一下我现在的工作，业务和离职原因，我也直言不讳的回答我的原因就是工资太低了，聊了一下我的工作经验，和我们公司从我去那时到现在的技术变化。</p><h3 id="面试题列表"><a href="#面试题列表" class="headerlink" title="面试题列表"></a>面试题列表</h3><p>一来就给一张纸，上面写了大概过程中会问的一些问题，如下：</p><ol><li>html的块元素和内联元素（此问题真的是很基础了，我也不说，面试官当然也没问了）</li><li>css的权重（唯一一道css相关题，我以为会问bfc，也一直准备的是bfc）<br>刚看到这个问题的时候大概脑子没有思考过来在问什么问题，也是平时工作中写css写的太多了，随手就能写那种，思考一会想到问的是内联样式，id选择器 类选择器之间的优先级问题。这个问题，面试官在过程中也没有，大概也是觉得过于基础了。</li><li>前端模块化，模块化的进化过程<br>这个问题我的回答很简单，大概说了3种模块化的方式<br>一、es6中的export import 这个在平时写组件的时候用的基本是这种方式<br>二、commonjs 的 module.export，require  这种方式在node 中使用比较<br>三、seajs 的define 方式<br>回答完我就觉得自己真的很low，只能看到表面，并不知道深层也不知道为什么会有模块化，平时的业务代码写太多很少有思考这种深层问题。</li><li>vue 生命周期和钩子函数</li><li>vue 全家桶（不明白问这个问题的原因是什么，意义何在）</li><li>js闭包是什么，怎么避免使用闭包，闭包的缺点</li><li>promise 怎么使用，应用场景<br>我的回答：promise 是es6中的语法，为了解决异步问题。然后拓展了一下异步的历史，由于浏览器是单进程多线程，很多操作都是异步的，最开始的异步是用callback 实现，然后ed6出来后用promise，后来有async await 方式。然后谈到async 是类一种写同步代码来实现异步功能。</li><li><p>写一个类，有自己的公共方法，私有方法，私有属性<br>我的回答说用typescript 中直接写，因为typescript 中已经有个这些语法了，private public 等相关关键词，然后面试官说让用es5方式写，这里我的面试的时候把私有属性和静态属性没有理解清楚，把静态属性理解成了私有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">    this.name = &apos;lei&apos; //共有属性能被实例拥有</span><br><span class="line">    var age = 12 // 私有属性 </span><br><span class="line">    var walk = function()&#123;</span><br><span class="line">        console.log(&apos;walk&apos;) // 私有方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.eat = function()&#123; //共有方法</span><br><span class="line">    console.log(&apos;eat&apos;) </span><br><span class="line">&#125;</span><br><span class="line">Person.last = &apos;y&apos; //静态属性 能够被子类继承</span><br></pre></td></tr></table></figure></li><li><p>描述从输入url到浏览器展示页面的整个流程经历哪些步骤</p></li></ol><h3 id="相关解答"><a href="#相关解答" class="headerlink" title="相关解答"></a>相关解答</h3><h4 id="前端模块化及历史"><a href="#前端模块化及历史" class="headerlink" title="前端模块化及历史"></a>前端模块化及历史</h4><p>前端模块可以把复杂的功能分开，增加复用性减小代码耦合度。通过只暴露接口不相互影响，污染。<br>发展历史：</p><ol><li>function 函数，编写各个功能的函数实现模块化，但是坏处可能会有重复命名，函数被重写，全局变量过多。</li><li><p>命名空间模式，简单对象封装。直接暴露内部函数给外部，外部可以直接修改内部数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var module = &#123;</span><br><span class="line">    data:&apos;12&apos;,</span><br><span class="line">    log:function()&#123;</span><br><span class="line">        console.log(this.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.data = 1234</span><br></pre></td></tr></table></figure></li><li><p>利用闭包，立即执行函数,可以防止外部函数直接内部数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window)&#123;</span><br><span class="line">    var data = &apos;123&apos;</span><br><span class="line">    function log()&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">    window.myModule = &#123;log&#125;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure></li></ol><p>以上模块化用过多的script 标签引入，且必须遵循一定的顺序引入。</p><p>模块化规范：</p><ol><li>commonjs规范:语法使用module.exports = xxx ,require 。暴露的export 是一个对象,在运行过程中加载，是同步加载，适合于服务端。加载的文件是输出值的拷贝。</li><li>AMD 规范:语法使用define([‘xxx.js’],function(){return xxx})，require([‘xxx.js’],function(m1){}) 是异步加载模块，适合于浏览器端. 代表库 requirejs</li><li>CMD 规范：结合commonjs 和 AMD 规范。使用的时候才加载模块，代表库 seajs<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">定义导出依赖</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    var a = reqiure(&apos;xxx.js&apos;)  //引入其他依赖</span><br><span class="line">    funtion log()&#123;&#125;</span><br><span class="line">    module.exports = &#123;log&#125;  //导出依赖</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">引入依赖</span><br><span class="line">define(function(require)&#123;</span><br><span class="line">    var m1 = require(&apos;xxx.js&apos;)</span><br><span class="line">    m1.log()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>CMD 和 AMD 区别： AMD 需要一开始就引入模块，CMD 可以就近引入模块，在需要的时候引入。</p><ol start="4"><li>es6 ，语法export import ，在编译的时候就确定好模块关系了，es6 的输出值是引用值。会改变依赖的内部数据。</li></ol><h3 id="描述从输入url到浏览器展示页面的整个流程经历哪些步骤"><a href="#描述从输入url到浏览器展示页面的整个流程经历哪些步骤" class="headerlink" title="描述从输入url到浏览器展示页面的整个流程经历哪些步骤"></a>描述从输入url到浏览器展示页面的整个流程经历哪些步骤</h3><ol><li>解析url 简称dns，获取到ip地址</li><li>浏览器开启网络请求线程发出http请求</li><li>服务端接收到请求发出响应</li><li>浏览器拿到html 解析html 文件</li><li>再次发出静态资源请求</li><li>拿到css js 图片等相关资源，生成渲染树，展示页面</li></ol>]]></content:encoded>
      
      <comments>http://yomark.club/%E8%AE%B02019%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://yomark.club/hello-world/</link>
      <guid>http://yomark.club/hello-world/</guid>
      <pubDate>Fri, 14 Jun 2019 13:13:33 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content:encoded>
      
      <comments>http://yomark.club/hello-world/#disqus_thread</comments>
    </item>
    
    <item>
      <title>遇坑记录</title>
      <link>http://yomark.club/%E9%81%87%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <guid>http://yomark.club/%E9%81%87%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Tue, 19 Sep 2017 14:19:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;最近的工作很忙，身心也很疲惫。算是真正的明白什么叫工作，什么叫恶心人。最近的工作都是在写移动端页面，其中也是遇到了很多坑。主要有其下几点。&lt;/p&gt;
&lt;ul&gt;&lt;br&gt;    &lt;li&gt;移动端穿透问题&lt;/li&gt;&lt;br&gt;    &lt;li&gt;按钮绑定事件内存泄露&lt;/li&gt;&lt;br&gt;    
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近的工作很忙，身心也很疲惫。算是真正的明白什么叫工作，什么叫恶心人。最近的工作都是在写移动端页面，其中也是遇到了很多坑。主要有其下几点。</p><ul><br>    <li>移动端穿透问题</li><br>    <li>按钮绑定事件内存泄露</li><br>    <li>css3 动画在真机上卡顿</li><br>    <li>‘img’标签下面空白</li><br></ul><h2 id="移动端穿透问题"><a href="#移动端穿透问题" class="headerlink" title="移动端穿透问题"></a>移动端穿透问题</h2><p>在上一篇将sass的时候就写了移动端穿透的解决方案，在实际共总工作中，我采用了第三种方案，为了实现需求需要把滚动条恢复在弹框出现之前，所以就用了scrollingElement.在chrome上模拟很正常，然后真机上测试就出现了问题。在使用这种方案之前就知道了这个api的兼容性可能会存在问题，所以就能直接锁定是它的兼容性问题，去查资料知道安卓上完全不支持。在此就只好使用它的polyfill(兼容性不好使用一个polyfill不是很正常的事吗，为此被人夸复制粘贴很屌，我也是有点醉的)。</p><h2 id="按钮绑定事件的内存泄露"><a href="#按钮绑定事件的内存泄露" class="headerlink" title="按钮绑定事件的内存泄露"></a>按钮绑定事件的内存泄露</h2><p>在写公司的页面弹框的时候我有一个需求是在某个时刻弹出一个弹窗A，然后点击这个A的按钮跳出下一个弹窗B。在A窗谈出来的时候判断其需要出现的东西，分为两种。<br>1.第一种是不需要跳出下一个B的。<br>2.第二种是需要跳出B的。<br>他们两个的按钮都是同一个class名字，所以相当于绑定事件的元素不变，而是改变了里面的内容，代码如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(item === 8)&#123;</span><br><span class="line">$(&apos;.btn&apos;).click(function()&#123;</span><br><span class="line">closeModle(A)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">$(&apos;.btn&apos;).click(()&#123;</span><br><span class="line">closeModle(A)</span><br><span class="line">openModle(B)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里出现的问题就是在弹出A之后，如何是item != 8 的情况下，弹出A并能成功跳出B，但是关闭B后再出现 item === 8 的情况，点击按钮后还是能弹出B。因为以前也从来没遇到过这个问题，所以去请教别人，奈何别人也不想告诉我，所以此事等了很久后才被解决。别人开始一直觉得是我单独给按钮绑定事件并在回调函数中判断item 的值来做出对应事件的问题。其实最后这个问题的主要原因就是内存泄漏，在给btn绑定事件后一直没有移除，所以他有一个弹B的动作在内存中，所以当B弹出后，if 无论是什么都会跳出B来。在这里就需要移除btn的click事件。jq中有unbind().我承认我在一个按钮的click事件中判断item 是有问题的，这样不易于移除这个按钮绑定事件。所以这个问题记住了。</p><h2 id="css3-动画真机上卡顿"><a href="#css3-动画真机上卡顿" class="headerlink" title="css3 动画真机上卡顿"></a>css3 动画真机上卡顿</h2><p>这个问题的出现也是在没有工作经验是不行的，我本身原来就很少写动画，这次需要在页面中实现一个全屏高度的漂浮物层浮动，这里就用了@keyfram做动画，在chrome上面运行也是很顺畅。但是在手机上，就出现了卡顿，本身这个页面需要加载的图片也很多，还需要运行这个动画。手机渲染完全跟不上，所以就造成了十分卡顿，上下滑动也不灵敏。解决方案是强制开启css3的GPU渲染。使用-webkit-transform:translateZ(0)，将这个设置为3d渲染，但是设置为0，所以并没有真的3d，但是浏览器却开启了GPU渲染模式。</p><h2 id="‘img’标签下面空白"><a href="#‘img’标签下面空白" class="headerlink" title="‘img’标签下面空白"></a>‘img’标签下面空白</h2><p>今天写页面遇到了这个神奇的问题，在banner图和下面的div之间有一小块空白区域，不属于banner也不属于div，我当时就很纳闷了，这个空白区域到底是怎么产生的。F12 一看banner的img 继承了哪些样式，基本没给它写任何会造成这方面的样式，然后看见从body那里继承了line-height，把line-height勾掉好像空白会改变一下。这样就能说明是这方面的问题了。通过google之后发现某大神说的是，img属于inline标签，同样会有font-size和line-height属性，在把font-size设置为0，就能解决这个问题。然后我采用的是设置vertical-aglin的方式，由于这个的默认是基于基线所以会有问题，设置好vertical-aglin同样可以达到目的。</p><p>以上就是最近在工作中遇到的主要问题，移动端的兼容问题真的是没有经验随时都是踩着坑前进的。这里随便吐槽一下，移动端竟然不支持es6，我也是很尴尬的啊，css3 都兼容的挺好的，es6却不兼容。</p><hr><p>更新补充<br>今天又在工作中遇到了一个以前没有考虑过的坑。也只能说是我自己对性能方面考虑的太少了。辣鸡代码：用动画切换来回一个div的背景图片做成一个开灯的效果。估计不考虑性能问题的最简单的方式就是直接替换背景图片，由于这个代码是一开始就写好的后来ui加的一个需求，所以就直接这样修改了。结果今天在线上测试环境测试的时候，由于图片太大加载不出来，然后以前也一直没有做过这方面的东西，所以被人说了。这样写的弊端就是每秒在改变背景图片在线上就是每秒请求两张图片，造成服务器压力过大。最后的解决方案是，做两个div在一个地方，一个div来回切换隐藏，在这里也补充了以前不知道的切换隐藏的方式。</p><h2 id="切换css-隐藏的方式"><a href="#切换css-隐藏的方式" class="headerlink" title="切换css 隐藏的方式"></a>切换css 隐藏的方式</h2><p>1。display:none.最简单也是用的最普遍的方式。<br>2.opacity 用过改变透明度达到视觉上的隐藏<br>3.visibility:hidden 改变可见和不可见<br>4.position:absolute left:-9999 top:-9999  这个方式用的很少。<br>平时用的最多的方式就是第一种，所以对这方面的问题又补充了。如果遇到更多问题还会继续补充。</p>]]></content:encoded>
      
      <comments>http://yomark.club/%E9%81%87%E5%9D%91%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>express 缓存</title>
      <link>http://yomark.club/express-%E7%BC%93%E5%AD%98/</link>
      <guid>http://yomark.club/express-%E7%BC%93%E5%AD%98/</guid>
      <pubDate>Sat, 16 Sep 2017 14:18:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;本文主要是记录做这个小实现遇到的问题和总结。&lt;br&gt;先说一下实现思路，在这里使用了npm的包（”memory-cache”）来做缓存，express做路由。重写了res.send,把设置缓存写进res.send 里面。完成send后把中间件转交给下一个中间件。这里缓存了整个
        
      
      </description>
      
      <content:encoded><![CDATA[<p>本文主要是记录做这个小实现遇到的问题和总结。<br>先说一下实现思路，在这里使用了npm的包（”memory-cache”）来做缓存，express做路由。重写了res.send,把设置缓存写进res.send 里面。完成send后把中间件转交给下一个中间件。这里缓存了整个页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var mcache = require(&quot;memory-cache&quot;)</span><br><span class="line">var cache = function(duration)&#123;</span><br><span class="line">    return function(req,res,next)&#123;</span><br><span class="line">        var key = req.originUrl || req.url</span><br><span class="line">        var mcachebody = mcache.get(key)</span><br><span class="line">        if(mcachebody)&#123;</span><br><span class="line">            res.send(mcachebody)</span><br><span class="line">            return</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.sendResponse = res.send</span><br><span class="line">            res.send = (body)=&gt;&#123;</span><br><span class="line">                mcache.put(key,body,duration*1000) // duration 设置成多少秒</span><br><span class="line">                res.sendResponse(body)</span><br><span class="line">            &#125;</span><br><span class="line">            next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心设置缓存就是以上代码，在实际使用中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/&quot;,cache(10),(req,res)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        res.render(&quot;index&quot;,&#123;name:&quot;hello&quot;,title:&quot;sb&quot;,date:new Date()&#125;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&apos;/user/:id&apos;,cache(10),(req,res)=&gt;&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        if(req.params.id ==1)&#123;</span><br><span class="line">            res.json(&#123;id:1,name:&quot;hi&quot;&#125;)</span><br><span class="line">        &#125;else if(req.params.id ==2)&#123;</span><br><span class="line">            res.json(&#123;id:2,name:&quot;lei&quot;&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">app.use((req,res)=&gt;&#123;</span><br><span class="line">    res.status(404).send(&quot;not found&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&quot;run on 3000 port&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在浏览器中打开localhost:3000，在2s后响应成功，设置了10s的缓存时间，10s内刷新整个页面都不会有改变（包括请求id） “localhost:3000/user/2” ，状态码也从200显示为304.这里顺便把状态码304搞懂了。</p><hr><p>在第一次写这篇文的时候当时不知道还有一个缓存的状态码是200，后来去搞清楚了，还有一种状态码200，直接从本地浏览器的缓存，并没有跟后台发起请求，而304是发起请求询问后台这个缓存有效否，有效就直接从浏览器那里获得。关于http方面的内容本人没有很深究过，理解也较浅，这些也是自己所学习到的东西。</p><hr><p>在实现的过程中主要遇到的问题就是http参数的请求解析没有搞清楚。解析http参数的方式主要是有以下几种。</p><ol><li>get请求查询类： /user?id=1;这里用query去解析参数出来。res.query.id //1</li><li>get 路由类：本例中使用的 /user/2 ;param解析 res.param（参数）,也可以用res.params.参数,params的能力更强，可以解析更为复杂的路径。<h3 id="res-send"><a href="#res-send" class="headerlink" title="res.send()"></a>res.send()</h3>用于向浏览器发送一个响应信息，如果是String则自动设置为content/type为text/html,如果是对象或者数组则设置为一个json对象，如果是数字就自动设置一个响应体  res.send(200) 返回一个OK。</li></ol>]]></content:encoded>
      
      <comments>http://yomark.club/express-%E7%BC%93%E5%AD%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>sass学习记录</title>
      <link>http://yomark.club/sass%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <guid>http://yomark.club/sass%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <pubDate>Wed, 13 Sep 2017 14:46:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;sass-学习经验&quot;&gt;&lt;a href=&quot;#sass-学习经验&quot; class=&quot;headerlink&quot; title=&quot;sass 学习经验&quot;&gt;&lt;/a&gt;sass 学习经验&lt;/h1&gt;&lt;h2 id=&quot;mixin的使用&quot;&gt;&lt;a href=&quot;#mixin的使用&quot; class=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="sass-学习经验"><a href="#sass-学习经验" class="headerlink" title="sass 学习经验"></a>sass 学习经验</h1><h2 id="mixin的使用"><a href="#mixin的使用" class="headerlink" title="mixin的使用"></a>mixin的使用</h2><p>sass 的mixin 宏使用方法:相当于函数，可以传入参数，但是mixin不可大量使用，会造成代码冗余。</p><h3 id="未带参数类型"><a href="#未带参数类型" class="headerlink" title="未带参数类型"></a>未带参数类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@mixin leftbar&#123;</span><br><span class="line">position:absolute;</span><br><span class="line">left:0;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">width:100px;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">@include leftbar</span><br><span class="line">&#125;</span><br><span class="line">.otherbox&#123;</span><br><span class="line">@include leftbar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的css 文件就会把leftbar 的内容放进div的样式中。不会自动合并使用相同样式的代码块。</p><h3 id="带参数类型"><a href="#带参数类型" class="headerlink" title="带参数类型"></a>带参数类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@mixin leftbar($width)&#123;</span><br><span class="line">position:absolute;</span><br><span class="line">left:0;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">width:$width</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">@include leftbar(200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mixin 的参数可以带多个，当参数过多可用…代替。由于大量的冗余代码，此功能最好适用于带有参数的重用代码块中，写死的代码块使用继承来做。</p><h2 id="类继承的使用"><a href="#类继承的使用" class="headerlink" title="类继承的使用"></a>类继承的使用</h2><p>@extend 如名所示，可以用来继承样式，mixin 的大量使用造成冗余，使用extend 可以做到降低冗余。@extend的用法就相当于设置一个类名.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.samestyle&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:70px;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">.otherbox&#123;</span><br><span class="line">@extend .samestyle</span><br><span class="line">&#125;</span><br><span class="line">.div&#123;</span><br><span class="line">@extend .samestyle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译出来的css 文件就会合并相同的样式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.otherbox,div&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:70px;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这点就解决了mixin的代码冗余问题。extend 的缺点也存在，由于它是类名，在使用中可能会造成混乱，最后sass也不知道哪个才是声明的类名。</p><h2 id="palceholder占位符的使用"><a href="#palceholder占位符的使用" class="headerlink" title="%palceholder占位符的使用"></a>%palceholder占位符的使用</h2><p>此功能暂时还没有怎么研究，简单来说跟mixin和继承的功能类似。</p><h2 id="sass定义变量"><a href="#sass定义变量" class="headerlink" title="sass定义变量"></a>sass定义变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$color:red</span><br><span class="line">div&#123;</span><br><span class="line">color:$color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以定义默认变量!default。如果要覆盖默认变量，在默认变量前重写变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$line-height:1.5</span><br><span class="line">$line-height:1.8 !default</span><br><span class="line">div&#123;</span><br><span class="line">line-height:$line-height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时生成的css 文件的line-height 为1.5</p><h2 id="sass-文件import"><a href="#sass-文件import" class="headerlink" title="sass 文件import"></a>sass 文件import</h2><p>sass 可以导入局部文件不用生成css文件，在文件命名加入下划线，导入的时候省略下划线。</p><h2 id="sass嵌套功能"><a href="#sass嵌套功能" class="headerlink" title="sass嵌套功能"></a>sass嵌套功能</h2><p>sass 的嵌套功能能让我们清楚的看到每个节点的相互关系，但是在方便和清晰的同时却不能忘记这个“好处”能让问题复杂化，在我初识sass的时候就是看上了这个嵌套功能以致于瞎用，滥用。完全没有考虑层级问题。一条路走到底。最后完全陷入混乱，继承关系太过复杂自己也理不清了。在某天系统的学习了一下sass后，也就是在学完后写了这篇学习笔记。<br>看了很多规范说嵌套最好的层级不要超过4层，本人的理解太深的层级会造成代码重叠和继承关系太过复杂，当在某个地方出错后很难定位哪里出问题。而且修改起来也较为麻烦，毕竟各个地方相互影响着。还有就是太深选择器的层次也就越深，在性能方面必然会影响一些，这个性能方面的问题没有深究。但是选择器如果多了对css的权重影响很大，在很多时候可能就是因为优先级权重问题修改样式失败。</p><h2 id="对于sass的使用"><a href="#对于sass的使用" class="headerlink" title="对于sass的使用"></a>对于sass的使用</h2><p>在我看来sass的强大之处应该是在于其减少css的代码，在我平时的工作在此项的使用还是很少，用的比较多的就是px转换到rem 的函数使用。还有用的比较多的是嵌套。在实际写css的时候对代码量的考虑太少，可能还是因为经验不足的原因对于某些常见样式的提取的敏感度不够。在今后的工作中可以试着提取相同代码模块化的形式写入。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>就css的问题在移动端上遇到了挺多了。就最近在写一个弹框的时候遇到了移动端穿透问题和定位问题。在我看来写弹框的定位最好还是使用fixed比较合适，看了别人的代码都是用的absolute写定位，在我使用绝对定位时候，由于页面的高度超过屏幕高度，所以在滑在下面的时候弹出弹框此时的定位就会错，如果是采用fixed就会相对屏幕定位每次弹出位置都在屏幕的中间。移动端穿透问题，简单说来就是弹出框后下面的图层还是可以点或者滑动。就解决方案有几种，我采用过两种，都有一点弊端。<br>1.弹出时将body设置成overflow:hidden。 这种方式确实也能解决到下面图层不能点击了，但是对于有bg的body 还是能够滑动，所以此种方案并不可行。<br>2.对弹出层监听touch事件并阻止其冒泡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dialog.addEventListener(&apos;touchmove&apos;,(e)=&gt;&#123;</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这种方案基本能解决我想要的需求不能点击且不能滑动。但是弊端就是如果弹出框的文本过多也不能滑动。在pc的chrome上模拟不能测试，请在真机上测试。</p><hr><h2 id="补充移动端穿透问题"><a href="#补充移动端穿透问题" class="headerlink" title="补充移动端穿透问题"></a>补充移动端穿透问题</h2><p>这次在工作中又写到一个需求需要在弹框里面滑动，所以这里上面讲的两种方案都是不可行的。这里就查到了第三种方案，就是在弹出弹框后给body的定位改成fixed，这样body就不能滑动了，但是缺陷就是滑动条会缺失。再深的需求就是要关闭弹框后滑动条还是在那个位置，就需要监听弹框弹出来时候body的scrolltop，在关闭弹框的事件把这个scrolltop设置上，这样就完美的解决了移动端穿透问题。</p>]]></content:encoded>
      
      <comments>http://yomark.club/sass%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
